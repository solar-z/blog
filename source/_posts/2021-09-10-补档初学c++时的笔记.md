---
layout: post
cid: 27
title: 补档初学c++时的笔记
slug: 27
date: 2021/09/10 16:25:00
updated: 2022/03/09 23:32:07
status: publish
author: solar-
categories: 
  - 默认分类
tags: 
customSummary: 
mathjax: auto
noThumbInfoStyle: default
outdatedNotice: no
reprint: standard
thumb: 
thumbChoice: default
thumbDesc: 
thumbSmall: 
thumbStyle: default
---


传一下当时学c++留的笔记，大概是20年疫情封控的时候写的，反正也没事做。
!!!
<h1 >tips</h1>
<h2 >visual studio 2017 tips</h2>
<p>1.在vs2017中提示找不到自己添加的某个文件，可以试试更改附加包含目录，此时注意如果是相对路径，应该是以项目的vcxproj后缀文件为基准的相对路径，输入时候给的提示可能是错误的。</p>
<h2 >犯过的错误集锦</h2>
<p>1.字符串字面值是const char*类型，无法自动转换为char*，如果有些函数的参数要求是char*类型会报错</p>
<p>2.不要用字符串操作函数的返回值初始化对象，在vs中会引起那一行的异常（还没搞懂为什么，先记录下来）</p>
<p>3.练习链表的时候遇到的问题，如果是想在链表末尾插入节点的话，不能使用如下代码,以下这种代码中的p指针并不是链表最后一个节点的next指针，只是p等于链表最后一个节点的next指针，他们都是null指针，对p使用malloc并不能更改链表</p>
<pre><code>p=head;//head是指向链表第一个节点的指针
while(p!=NULL){
	p=p-&gt;next;
}
p=(struct listnode*)malloc(sizeof(struct listnode));
p-&gt;next-&gt;data = num;
p-&gt;next-&gt;next = NULL;

</code></pre>
<p>应该使用以下这种</p>
<pre><code>p = head;
while (p-&gt;next != NULL) {
	p = p-&gt;next;
}
p-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode));
p-&gt;next-&gt;data = num;
p-&gt;next-&gt;next = NULL;
</code></pre>
<p>这样就可以真正的更改链表</p>
<p>如果只是遍历链表而不是要添加节点那么不用这样做。</p>
<p>4，注意这篇md所有的tip都可能被编译器的优化所影响，建议使用 -fno-elide-constructors 关闭优化</p>
<h2 >函数返回值的理解</h2>
<p>函数的返回值其实相当于初始化了一个临时变量,然后把用函数里面return的值初始化<strong>(这可能就是函数返回对象时会调用复制构造函数的原因</strong>),在调用这个函数的语句中,函数名就等价于这个临时变量,在调用语句执行结束之后这个临时变量就要消亡  <strong>[因为是额外声明的临时变量作为返回值,所以如果在调用函数的语句中把函数名放在赋值语句的左边,可以对这个临时变量进行赋值,如果这个函数返回的这个临时变量是引用类型,那么则可以进一步修改函数中用到的全局变量或者对象成员变量]</strong></p>
<h2 >必须使用初始化列表的情况</h2>
<p>有三种情况必须需要初始化列表而不能使用赋值语句(在csdn里查到的<a href='https://blog.csdn.net/u014725884/article/details/47004509' target='_blank' class='url'>https://blog.csdn.net/u014725884/article/details/47004509</a>)</p>
<ol>
<li>类成员为const类型</li>
<li>类成员为引用类型</li>
<li>类成员为没有默认构造函数的类类型</li>
<li>如果类存在继承关系，派生类必须在其初始化列表中调用基类的构造函数(写下这条的时候还没学过第四条,不能弄清对错)</li>

</ol>
<p>&nbsp;</p>
<h1 >从c到c++</h1>
<p>&nbsp;</p>
<h2 >const</h2>
<p>1,常量在声明的时候就必须初始化,在之后不能改变，常量指针不能赋值给非常量指针</p>
<p>2,不能通过常量指针和常引用改变所指向或者引用的内容,但是所指向和引用的内容仍然可以以其他方式被修改,</p>
<p>3,非常量指针和非常引用不能用常量指针和常引用初始化,除非进行强制类型转换.</p>
<p>4,不能把常量指针和常引用赋值给非常量指针和非常引用(这条的意义大概和上一条一样)</p>
<h1 >类和对象基础</h1>
<h2 >构造函数调用顺序</h2>
<pre><code>#include &lt;iostream&gt;
class base{
		public:
	base(){
		std::cout&lt;&lt;&quot;base construct&quot;&lt;&lt;std::endl;
	}
	
};
class car{
		public:
	car(){
		std::cout&lt;&lt;&quot;car construct&quot;&lt;&lt;std::endl;
	}
	
};
class derive:public base{
	car b;
	public:
	derive(){
		std::cout&lt;&lt;&quot;derive construct&quot;&lt;&lt;std::endl;
	}
	
	
};

int main(){
	derive d;
	
	return 0;
} 
</code></pre>
<p>结果：</p>
<pre><code>base construct
car construct
derive construct

--------------------------------
Process exited after 0.04906 seconds with return value 0
请按任意键继续. . .
</code></pre>
<p>说明对于派生类对象d来说，构造函数的调用顺序是：</p>
<p>d的父类对象-&gt;d的成员对象-&gt;d</p>
<p>&nbsp;</p>
<h2 >构造函数</h2>
<p>假设A是已经定义好的class</p>
<pre><code>A a(n);
a=A(m);
</code></pre>
<p>第一行的语句显然是初始化对象a</p>
<p>第二行语句的意思是重新调用类A的构造函数并且对a进行赋值。</p>
<p><strong>以下某些结果在不同编译器中结果可能不同</strong></p>
<h3 >关于构造函数和析构函数的作用</h3>
<p>构造函数并不是给对象分配空间,他只是给已经份分配空间的对象进行初始化</p>
<p>析构函数有不是把对象的存储空间free掉,在对象生命周期结束的时候,系统会自动free这些对象占用的存储空间,析构函数在这之前被调用,做一些工作</p>
<h3 >关于初始化语句和赋值语句的区别</h3>
<p>1,complex为类名,c1和c2都是对象;</p>
<pre><code>complex c1(c2);
</code></pre>
<p>这个是初始化语句</p>
<pre><code>c1=c2;
</code></pre>
<p>这个是赋值语句</p>
<pre><code>complex c1=c2;
</code></pre>
<p>这个也是初始化语句(这里容易搞错)</p>
<h3 >移动构造函数</h3>
<ul>
<li>移动构造函数的参数是左值引用，只能接受左值。</li>

</ul>
<h3 >复制构造函数</h3>
<ul>
<li>复制构造函数的参数是右值引用时，只接受右值，当参数是const左值引用时，既接受左值也接受右值，但若有移动构造函数，则右值优先由移动构造函数接受。</li>

</ul>
<p>0.复制构造函数只是构造函数在对象创建时起到复制作用时候的别称（复制构造函数只会在某个对象初始化（也就是创建）的时候调用，使用=的赋值操作不调用复制构造函数，=是直接复制，所以是浅拷贝）</p>
<p>1,有三种方式会调用复制构造函数;</p>
<p>第一种,用一个对象初始化一个对象(引用语句不算)</p>
<p>第二种 对象作为函数参数(是对象作为参数,对象的引用作为参数时不会调用复制构造函数)</p>
<p>第三种 对象作为函数法返回值,会先把函数里面的return返回的对象赋值给一个临时对象,然后返回这个临时对象(在调用函数的语句种,函数名此时就是一个对象,即刚刚提到的临时对象),在调用函数的整个语句结束之后,临时对象消亡.（可能会被编译器优化所影响 ，使用 -fno-elide-constructors 关闭优化）</p>
<p>2,复制构造函数的参数一般是引用或者从常引用,,因为直接使用类作为参数会导致复制构造函数的无限递归,但是引用和直接复制不同,引用并不会调用复制构造参数,这就避免了无限递归</p>
<p>3,复制构造函数结束时,这个复制构造函数的参数变量会消亡,但此时并不会调用析构函数,因为这个消亡的参数变量的类型是类的引用,不是类,所以不会调用析构函数</p>
<p>4.直接赋值两个对象不会触发复制构造函数（因为不需要创建任何对象或者临时对象，所以不会调用任何构造函数）。只要出现了构造函数的调用，就意味着肯定出现了一个新对象（这个新对象可能并不是我们手动创造的，他可能是用完就消亡的临时对象，这时候临时对象的创建和消亡会触发构造函数和析构函数）。</p>
<h3 >类型转换构造函数</h3>
<p>（注意以下说明都可能被编译器自带的优化影响，可以使用 -fno-elide-constructors 关闭优化）</p>
<p>0.类型转换构造函数只是构造函数起到了类型转换时候的别称。（可能是以下两种情况(A是类名）</p>
<pre><code class='language-c++' lang='c++'>A a(11);（此时调用有合适参数的构造函数用于把11转换并创建这个对象；
</code></pre>
<p>或者</p>
<pre><code>A a;(假设A有无参构造函数)
a=11;（此时如果有合适的重载=运算符，就会优先调用重载运算符，如果没有的话，就会调用有合适参数的构造函数用于类型转换来创建一个临时对象，然后通过普通的=运算符直接把临时对象赋值给a，然后临时对象消亡（会调用析构函数））
</code></pre>
<p>&nbsp;</p>
<p>1,如果是以初始化的方式，那么</p>
<pre><code>A a=11;//这种写法会先以11为参数调用类型转换构造函数生成一个对象，然后再以这个临时对象为参数调用复制构造函数生成对象a，（但是这种写法可能会被编译器优化成A a(11),然后就只调用一次类型转换构造函数直接生成对象a，建议开启-fno-elide-constructors关闭优化。）
</code></pre>
<p>2.如果是在声明对象的语句结束之后,再另有一个赋值语句把其他的类型比如int赋值给对象,那么此时系统就会先寻找有没有重载的赋值运算符可用，如果有就用重载的运算符，如果没有就再看看能不能调用类型转换构造函数来制造一个临时对象,然后以直接赋值的方式把临时对象赋值给等号左边的变量.</p>
<h3 >析构函数</h3>
<p>0.析构函数在对象消亡之前调用，不管析构函数是默认还是自定义</p>
<p>1.在计算析构函数的调用时候要注意到,必须等到某个对象生命周期结束才会调用析构函数,但是new出来的对象,它的生命周期是由用户控制的,如果不去delete这个对象,那么它的生命周期在整个进程一直不会结束,也就是说如果没有delete一个new出来的对象,那么永远不会看到因为这个对象的消亡而调用调用析构函数.</p>
<p>2.在一个对象生命周期结束的时候，对象的所有成员都会自动消亡（不是通过析构函数实现的，默认析构函数是空的，成员消亡只是因为对象本身的空间释放了），我们自定义的析构函数只需要做这之外的工作就好了（比如delete掉new出来的东西），本身的成员所占用空间（比如用来对象中某个用来指向new出来的空间的指针）的释放不需要我们管，随着对象本身的消亡成员直接就会消亡</p>
<p>&nbsp;</p>
<h1 >类和对象提高</h1>
<h2 >this指针</h2>
<p>在c++中某些成员函数的参数会被编译器自动添加一个this指针(静态成员函数除外,静态成员函数的形参就是实际看到的个数),this指针指向这个函数作用的对象.,</p>
<h2 >成员对象和封闭类</h2>
<p>1.在封闭类进行初始化的时候，会使用这个封闭类的构造函数，这个封闭类的构造函数显然会进一步调用成员对象的构造函数，如果这个封闭类的成员对象的构造函数必须需要传入参数，那么在封闭类的构造函数中必须给出成员对象的构造函数所需要的参数,在这时必须要使用初始化列表,而不能在函数内部赋值,因为任何对象在一开始就必须被初始化(<strong>因为对于没有无参构造函数的成员对象,初始化需要参数</strong>),</p>
<p>2.封闭类的默认复制构造函数会自动调用成员对象的复制构造函数.</p>
<h2 >常量对象和常量成员函数</h2>
<p>1,常量对象上不能调用非常量成员函数(<strong>即非常量成员函数所作用的对象必须是非常量成员函数</strong>)所以如果想使用常量对象的函数,那么这个函数必须有const</p>
<p>2,常量对象的this指针也是const类型,在返回this指针的时候要注意返回类型要写const,不然编译器会报错</p>
<h1 >运算符重载</h1>
<h3 >赋值运算符的重载</h3>
<p>1.</p>
<pre><code>Complex a;
a=&quot;good luck&quot;;
</code></pre>
<p>这里Complex是类名，第二行的等号会调用赋值运算符重载的函数</p>
<pre><code>Complex a=“good luck”;
</code></pre>
<p>这里是初始化语句不是赋值语句，这里的等号并不是赋值符号，所以只会调用复制构造函数，如果没有参数为char*的复制构造函数那么就会出错。</p>
<p>2.如果对赋值运算符没有重载过，在给对象赋值的时候编译器会寻找可用的类型转换构造函数，但是如过对赋值运算符进行了重载，那么编译器将可能既不会寻找可用的类型转换构造函数来适应旧的赋值运算符，也不会寻找可用的类型转换函数来适应重载后的赋值运算符，也就是说在赋值运算符重载之后，对于某一个赋值语句，如果仍然没有可用于的重载函数，编译器将直接报错，而不是去寻找类型转换构造函数来适应赋值运算符（无论是重载前的还是重载之后的）</p>
<h1 >静态局部变量</h1>
<h2 >1.静态局部变量与递归</h2>
<p>函数每次递归都是新开辟的一个内存空间，如果在函数体里声明了普通局部变量，那么每递归一层，这个变量和上一层都已经不是同一个变量了</p>
<p>但是如果是在函数体里生命的静态局部变量，比如下面这句（假设这句是写在某个函数里）</p>
<pre><code>static int x=0;
</code></pre>
<p>那么无论递归多少层，这个变量都会一直存在，而且即使在递归中再次执行了这一个语句，也不会重新定义一个新的变量，始终都只有这一个，而且在递归中再次执行到这一个语句的时候，这一句会被直接忽略，即使后面有“x=0”这样的初始化语句，x的值也不会变化，因为这一句属于是初始化语句而不是赋值语句，静态局部变量的第二次初始化被完全忽略了</p>
<h1 >静态成员变量</h1>
<p>静态成员变量必须初始化，而且要在类外</p>
<p>格式是 类型名+类名+：：+变量名（+等号+初始值）；</p>
<p>不需要在前面再写static</p>
<h1 >隐藏和覆盖（重写）</h1>
<p>1,隐藏并不要求函数的参数表相同，只要函数名相同即可隐藏。之前的函数被隐藏之后，在调用函数的时候，编译器看不到之前被隐藏的函数，如果后来的函数参数表不符合，编译器并不会去找之前被隐藏掉的函数，而是会直接报错</p>
<p>覆盖（重写）即为使用虚函数和多态，要求函数参数表也要相同。</p>
<p>隐藏和覆盖，都可以通过作用域运算符强制改变搜寻时的作用域，来调用先前的函数。</p>
<p>隐藏没有多态的特性，覆盖（重写）有多态特性。</p>
<p>如果使用基类指针或者基类引用来调用成员函数或者成员变量，隐藏不会触发多态，而覆盖（重写）会触发多态。</p>
<p>下面是示例代码，再往下有devc++运行结果</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
class A
{
public:
	void f(){
		cout&lt;&lt;&quot;f1&quot;&lt;&lt;endl;
	}
	virtual void g(){
		cout&lt;&lt;&quot;g1&quot;&lt;&lt;endl;
	}
};
class B:public A
{
public:
	void f(int x){
		cout&lt;&lt;&quot;f2&quot;&lt;&lt;endl;
	}
	virtual void g(){
		cout&lt;&lt;&quot;g2&quot;&lt;&lt;endl;
	}
};
int main()
{
	A* a=new B;
	a-&gt;f();
	a-&gt;g();
	return 0;
}
</code></pre>
<p>运行结果
f1
g2</p>
<hr />
<p>Process exited after 0.04111 seconds with return value 0
请按任意键继续. . .</p>
<p>3.在成员函数g()中调用一个成员函数f()时，实际上为this-&gt;f()，所使用的this指针类型为g()所在类的指针类型.</p>
<h1 >动态内存与智能指针</h1>
<ul>
<li>建议使用make_shared和make_unique，不要使用构造函数。</li>

</ul>
<h2 >unique_ptr</h2>
<ul>
<li>没有复制构造函数，只有移动构造函数（参数是右值引用），所以只能用右值构造，不能用左值构造。</li>
<li>整个程序中，只有一个unique_ptr能够持有某一个对象，若构造函数试图多次传入同一个地址则报错。</li>
<li>只能移动构造，所以如果unique_ptr的左值作为vector.push_back的参数，则必须先用std::move转为右值，从而使用push_back的右值重载版本来进行移动构造。如果不加std::move，则会报错，因为进入push_back的左值重载版本后会发现没有复制构造函数。</li>

</ul>
<h2 >stl与智能指针（以vector.push_back为例）</h2>
<ul>
<li>vector.push_back有const左值引用和右值引用两个重载版本，前者接受左值，后者接受右值。</li>
<li>若push_back参数为右值，则当vector中存放的变量有noexcept的移动构造函数时，使用移动构造函数。（一部分编译器会对移动构造函数自动检测是否抛出exception，若没有则自动加上noexcept）</li>
<li>若push_back参数为左值，则使用复制构造函数。</li>

</ul>
<h2 >shared_ptr</h2>
<ul>
<li>有复制构造函数</li>
<li>可以有多个ptr持有同一个对象，有计数器，为0自动析构。</li>

</ul>
!!!